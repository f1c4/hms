
  create table "public"."examination_types" (
    "id" bigint generated by default as identity not null,
    "type_key" text not null,
    "name_translations" jsonb not null,
    "description_translations" jsonb,
    "preparation_instructions_translations" jsonb,
    "duration_minutes" integer not null,
    "base_price" numeric(10,2),
    "category" text,
    "color" text,
    "sort_order" integer default 0,
    "is_active" boolean not null default true,
    "requires_referral" boolean not null default false,
    "requires_fasting" boolean not null default false,
    "requires_appointment" boolean not null default true,
    "ai_source_locale" text,
    "ai_translation_status" text default 'pending'::text,
    "ai_translation_error" text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone,
    "created_by" uuid,
    "updated_by" uuid,
    "version" integer not null default 1
      );


alter table "public"."examination_types" enable row level security;

CREATE UNIQUE INDEX examination_types_pkey ON public.examination_types USING btree (id);

CREATE UNIQUE INDEX examination_types_type_key_key ON public.examination_types USING btree (type_key);

alter table "public"."examination_types" add constraint "examination_types_pkey" PRIMARY KEY using index "examination_types_pkey";

alter table "public"."examination_types" add constraint "examination_types_ai_translation_status_check" CHECK ((ai_translation_status = ANY (ARRAY['pending'::text, 'in_progress'::text, 'completed'::text, 'failed'::text]))) not valid;

alter table "public"."examination_types" validate constraint "examination_types_ai_translation_status_check";

alter table "public"."examination_types" add constraint "examination_types_base_price_check" CHECK ((base_price >= (0)::numeric)) not valid;

alter table "public"."examination_types" validate constraint "examination_types_base_price_check";

alter table "public"."examination_types" add constraint "examination_types_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."examination_types" validate constraint "examination_types_created_by_fkey";

alter table "public"."examination_types" add constraint "examination_types_duration_minutes_check" CHECK (((duration_minutes > 0) AND (duration_minutes <= 480))) not valid;

alter table "public"."examination_types" validate constraint "examination_types_duration_minutes_check";

alter table "public"."examination_types" add constraint "examination_types_type_key_key" UNIQUE using index "examination_types_type_key_key";

alter table "public"."examination_types" add constraint "examination_types_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES auth.users(id) not valid;

alter table "public"."examination_types" validate constraint "examination_types_updated_by_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.get_patient_list_basic(p_limit integer DEFAULT 20, p_offset integer DEFAULT 0, p_first_name text DEFAULT NULL::text, p_last_name text DEFAULT NULL::text, p_national_id text DEFAULT NULL::text, p_phone text DEFAULT NULL::text, p_sort text DEFAULT 'created_at'::text, p_order text DEFAULT 'desc'::text, p_min_chars integer DEFAULT 2)
 RETURNS jsonb
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_total_count BIGINT;
  v_filtered_count BIGINT;
  v_data JSONB;
  v_is_asc BOOLEAN;
  v_has_filters BOOLEAN;
  v_first_name TEXT;
  v_last_name TEXT;
  v_national_id TEXT;
  v_phone TEXT;
BEGIN
  v_is_asc := LOWER(p_order) = 'asc';

  -- Normalize filters: treat as NULL if empty or below minimum character threshold
  v_first_name := CASE 
    WHEN p_first_name IS NOT NULL AND LENGTH(TRIM(p_first_name)) >= p_min_chars 
    THEN TRIM(p_first_name) 
    ELSE NULL 
  END;
  
  v_last_name := CASE 
    WHEN p_last_name IS NOT NULL AND LENGTH(TRIM(p_last_name)) >= p_min_chars 
    THEN TRIM(p_last_name) 
    ELSE NULL 
  END;
  
  v_national_id := CASE 
    WHEN p_national_id IS NOT NULL AND LENGTH(TRIM(p_national_id)) >= p_min_chars 
    THEN TRIM(p_national_id) 
    ELSE NULL 
  END;
  
  v_phone := CASE 
    WHEN p_phone IS NOT NULL AND LENGTH(TRIM(p_phone)) >= p_min_chars 
    THEN TRIM(p_phone) 
    ELSE NULL 
  END;

  v_has_filters := v_first_name IS NOT NULL 
                OR v_last_name IS NOT NULL 
                OR v_national_id IS NOT NULL 
                OR v_phone IS NOT NULL;

  -- Fast approximate count for total (O(1) lookup)
  SELECT COALESCE(reltuples::BIGINT, 0) 
  INTO v_total_count 
  FROM pg_class 
  WHERE relname = 'patient_general' AND relnamespace = 'public'::regnamespace;

  IF NOT v_has_filters THEN
    v_filtered_count := v_total_count;
  ELSE
    SELECT COUNT(*) INTO v_filtered_count
    FROM patient_general
    WHERE 
      (v_first_name IS NULL OR first_name ILIKE '%' || v_first_name || '%')
      AND (v_last_name IS NULL OR last_name ILIKE '%' || v_last_name || '%')
      AND (v_national_id IS NULL OR national_id_number ILIKE '%' || v_national_id || '%')
      AND (v_phone IS NULL OR phone ILIKE '%' || v_phone || '%');
  END IF;

  SELECT COALESCE(jsonb_agg(row_data), '[]'::jsonb)
  INTO v_data
  FROM (
    SELECT 
      jsonb_build_object(
        'id', pg.id,
        'firstName', pg.first_name,
        'lastName', pg.last_name,
        'nationalIdNumber', pg.national_id_number,
        'dateOfBirth', pg.date_of_birth,
        'phone', pg.phone,
        'email', pg.email,
        'residenceAddress', pg.residence_address,
        'residenceCountryIso2', c.iso2,
        'residenceCityName', ci.name,
        'residenceCityPostalCode', ci.postal_code,
        'emergencyContactName', pg.emergency_contact_name,
        'emergencyContactPhone', pg.emergency_contact_phone,
        'emergencyContactRelation', pg.emergency_contact_relation,
        'createdAt', pg.created_at,
        'updatedAt', pg.updated_at
      ) AS row_data
    FROM patient_general pg
    LEFT JOIN countries c ON pg.residence_country_id = c.id
    LEFT JOIN cities ci ON pg.residence_city_id = ci.id
    WHERE 
      (v_first_name IS NULL OR pg.first_name ILIKE '%' || v_first_name || '%')
      AND (v_last_name IS NULL OR pg.last_name ILIKE '%' || v_last_name || '%')
      AND (v_national_id IS NULL OR pg.national_id_number ILIKE '%' || v_national_id || '%')
      AND (v_phone IS NULL OR pg.phone ILIKE '%' || v_phone || '%')
    ORDER BY
      CASE WHEN p_sort = 'created_at' AND v_is_asc THEN pg.created_at END ASC NULLS LAST,
      CASE WHEN p_sort = 'created_at' AND NOT v_is_asc THEN pg.created_at END DESC NULLS LAST,
      CASE WHEN p_sort = 'first_name' AND v_is_asc THEN pg.first_name END ASC NULLS LAST,
      CASE WHEN p_sort = 'first_name' AND NOT v_is_asc THEN pg.first_name END DESC NULLS LAST,
      CASE WHEN p_sort = 'last_name' AND v_is_asc THEN pg.last_name END ASC NULLS LAST,
      CASE WHEN p_sort = 'last_name' AND NOT v_is_asc THEN pg.last_name END DESC NULLS LAST,
      CASE WHEN p_sort = 'date_of_birth' AND v_is_asc THEN pg.date_of_birth END ASC NULLS LAST,
      CASE WHEN p_sort = 'date_of_birth' AND NOT v_is_asc THEN pg.date_of_birth END DESC NULLS LAST
    LIMIT p_limit
    OFFSET p_offset
  ) subquery;

  RETURN jsonb_build_object(
    'data', v_data,
    'filteredCount', v_filtered_count,
    'totalCount', v_total_count,
    'pagination', jsonb_build_object(
      'page', (p_offset / p_limit) + 1,
      'limit', p_limit,
      'totalPages', CEIL(v_filtered_count::DECIMAL / p_limit)
    )
  );
END;
$function$
;

grant delete on table "public"."companies" to "postgres";

grant insert on table "public"."companies" to "postgres";

grant references on table "public"."companies" to "postgres";

grant select on table "public"."companies" to "postgres";

grant trigger on table "public"."companies" to "postgres";

grant truncate on table "public"."companies" to "postgres";

grant update on table "public"."companies" to "postgres";

grant delete on table "public"."examination_types" to "anon";

grant insert on table "public"."examination_types" to "anon";

grant references on table "public"."examination_types" to "anon";

grant select on table "public"."examination_types" to "anon";

grant trigger on table "public"."examination_types" to "anon";

grant truncate on table "public"."examination_types" to "anon";

grant update on table "public"."examination_types" to "anon";

grant delete on table "public"."examination_types" to "authenticated";

grant insert on table "public"."examination_types" to "authenticated";

grant references on table "public"."examination_types" to "authenticated";

grant select on table "public"."examination_types" to "authenticated";

grant trigger on table "public"."examination_types" to "authenticated";

grant truncate on table "public"."examination_types" to "authenticated";

grant update on table "public"."examination_types" to "authenticated";

grant delete on table "public"."examination_types" to "postgres";

grant insert on table "public"."examination_types" to "postgres";

grant references on table "public"."examination_types" to "postgres";

grant select on table "public"."examination_types" to "postgres";

grant trigger on table "public"."examination_types" to "postgres";

grant truncate on table "public"."examination_types" to "postgres";

grant update on table "public"."examination_types" to "postgres";

grant delete on table "public"."examination_types" to "service_role";

grant insert on table "public"."examination_types" to "service_role";

grant references on table "public"."examination_types" to "service_role";

grant select on table "public"."examination_types" to "service_role";

grant trigger on table "public"."examination_types" to "service_role";

grant truncate on table "public"."examination_types" to "service_role";

grant update on table "public"."examination_types" to "service_role";

grant delete on table "public"."professions" to "postgres";

grant insert on table "public"."professions" to "postgres";

grant references on table "public"."professions" to "postgres";

grant select on table "public"."professions" to "postgres";

grant trigger on table "public"."professions" to "postgres";

grant truncate on table "public"."professions" to "postgres";

grant update on table "public"."professions" to "postgres";


  create policy "Allow authenticated users to delete examination_types"
  on "public"."examination_types"
  as permissive
  for delete
  to authenticated
using (true);



  create policy "Allow authenticated users to insert examination_types"
  on "public"."examination_types"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Allow authenticated users to read examination_types"
  on "public"."examination_types"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Allow authenticated users to update examination_types"
  on "public"."examination_types"
  as permissive
  for update
  to authenticated
using (true);



  create policy "Allow service_role full access on examination_types"
  on "public"."examination_types"
  as permissive
  for all
  to service_role
using (true);




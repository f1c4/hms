
  create table "public"."professions" (
    "id" bigint generated by default as identity not null,
    "name_translations" jsonb not null,
    "ai_source_locale" text,
    "ai_translation_status" text default 'pending'::text,
    "ai_translation_error" text,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."professions" enable row level security;

alter table "public"."patient_personal" drop column "employer_name";

alter table "public"."patient_personal" drop column "profession";

alter table "public"."patient_personal" add column "employer_id" bigint;

alter table "public"."patient_personal" add column "profession_id" bigint;

CREATE UNIQUE INDEX professions_pkey ON public.professions USING btree (id);

alter table "public"."professions" add constraint "professions_pkey" PRIMARY KEY using index "professions_pkey";

alter table "public"."patient_personal" add constraint "patient_personal_employer_id_fkey" FOREIGN KEY (employer_id) REFERENCES public.companies(id) not valid;

alter table "public"."patient_personal" validate constraint "patient_personal_employer_id_fkey";

alter table "public"."patient_personal" add constraint "patient_personal_profession_id_fkey" FOREIGN KEY (profession_id) REFERENCES public.professions(id) not valid;

alter table "public"."patient_personal" validate constraint "patient_personal_profession_id_fkey";

alter table "public"."professions" add constraint "professions_ai_translation_status_check" CHECK ((ai_translation_status = ANY (ARRAY['pending'::text, 'in_progress'::text, 'completed'::text, 'failed'::text]))) not valid;

alter table "public"."professions" validate constraint "professions_ai_translation_status_check";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.get_full_patient_data(p_patient_id integer)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  general_data JSON;
  personal_data JSON;
  risk_data JSON;
  notes_data JSON;
  id_documents_data JSON;
  insurances_data JSON;
BEGIN
  -- =================================================================
  -- Get general data --
  -- =================================================================
  SELECT json_build_object(
    -- Include all original snake_case columns from the table
    'id', pg.id,
    'created_at', pg.created_at,
    'updated_at', pg.updated_at,
    'created_by', pg.created_by,
    'updated_by', pg.updated_by,
    'version', pg.version,
    'first_name', pg.first_name,
    'last_name', pg.last_name,
    'date_of_birth', pg.date_of_birth,
    'phone', pg.phone,
    'email', pg.email,
    'residence_address', pg.residence_address,
    'national_id_number', pg.national_id_number,
    'emergency_contact_name', pg.emergency_contact_name,
    'emergency_contact_phone', pg.emergency_contact_phone,
    'emergency_contact_relation', pg.emergency_contact_relation,
    'residence_country_id', pg.residence_country_id,
    'residence_city_id', pg.residence_city_id,
    'citizenship_country_id', pg.citizenship_country_id,
    -- derived camelCase fields
    'residenceCountryIso2', rc.iso2,
    'citizenshipCountryIso2', cc.iso2,
    'residenceCity', CASE WHEN rci.id IS NOT NULL THEN json_build_object(
      'id', rci.id,
      'name', rci.name,
      'postal_code', rci.postal_code
    ) ELSE NULL END
  ) INTO general_data
  FROM patient_general pg
  LEFT JOIN countries rc ON pg.residence_country_id = rc.id
  LEFT JOIN countries cc ON pg.citizenship_country_id = cc.id
  LEFT JOIN cities rci ON pg.residence_city_id = rci.id
  WHERE pg.id = p_patient_id;

  -- =================================================================
  -- Get identity documents for the patient --
  -- =================================================================
  SELECT json_agg(
    json_build_object(
      'id', d.id,
      'patient_id', d.patient_id,
      'document_type', d.document_type,
      'document_number', d.document_number,
      'issue_date', d.issue_date,
      'expiry_date', d.expiry_date,
      'file_path', d.file_path,
      'file_name', d.file_name,
      'file_size', d.file_size,
      'file_type', d.file_type,
      'version', d.version,
      'created_at', d.created_at,
      'updated_at', d.updated_at,
      'created_by', d.created_by,
      'updated_by', d.updated_by,
      -- The flat, derived, camelCase field for the label
      'documentTypeTranslations', dt.translations
    )
  ) INTO id_documents_data
  FROM patient_id_documents d
  LEFT JOIN document_types dt ON d.document_type = dt.id
  WHERE d.patient_id = p_patient_id;

  -- =================================================================
  -- Get insurance policies for the patient --
  -- =================================================================
  SELECT json_agg(
    json_build_object(
      'id', pi.id,
      'patient_id', pi.patient_id,
      'plan_id', pi.plan_id,
      'policy_number', pi.policy_number,
      'lbo_number', pi.lbo_number,
      'is_active', pi.is_active,
      'effective_date', pi.effective_date,
      'expiry_date', pi.expiry_date,
      'file_path', pi.file_path,
      'file_name', pi.file_name,
      'file_size', pi.file_size,
      'file_type', pi.file_type,
      'version', pi.version,
      'created_at', pi.created_at,
      'updated_at', pi.updated_at,
      'created_by', pi.created_by,
      'updated_by', pi.updated_by,
      -- Nested plan and provider details
      'plan', json_build_object(
        'id', ip.id,
        'provider_id', ip.provider_id,
        'name_translations', ip.name_translations,
        'description_translations', ip.description_translations,
        'coverage_details', ip.coverage_details,
        'provider', json_build_object(
          'id', ipv.id,
          'name_translations', ipv.name_translations,
          'contact_info', ipv.contact_info
        )
      )
    )
  ) INTO insurances_data
  FROM patient_insurances pi
  LEFT JOIN insurance_plans ip ON pi.plan_id = ip.id
  LEFT JOIN insurance_providers ipv ON ip.provider_id = ipv.id
  WHERE pi.patient_id = p_patient_id;

  -- =================================================================
  -- Get personal data --
  -- =================================================================
  SELECT json_build_object(
  -- ... existing fields ...
  'id', pp.id,
  'patient_id', pp.patient_id,
  'created_at', pp.created_at,
  'updated_at', pp.updated_at,
  'created_by', pp.created_by,
  'updated_by', pp.updated_by,
  'version', pp.version,
  'parent_name', pp.parent_name,
  'marital_status', pp.marital_status,
  'profession_id', pp.profession_id,
  'education_level', pp.education_level,
  'employer_id', pp.employer_id,  -- Changed from employer_name
  'employment_status', pp.employment_status,
  'living_arrangement', pp.living_arrangement,
  'birth_country_id', pp.birth_country_id,
  'birth_city_id', pp.birth_city_id,

  -- Derived camelCase fields
  'birthCountryIso2', bc.iso2,
  'birthCity', CASE WHEN bci.id IS NOT NULL THEN json_build_object(
    'id', bci.id,
    'name', bci.name,
    'postal_code', bci.postal_code
  ) ELSE NULL END,
  'profession', CASE WHEN prof.id IS NOT NULL THEN json_build_object(
    'id', prof.id,
    'name_translations', prof.name_translations
  ) ELSE NULL END,
  -- Add employer object
  'employer', CASE WHEN emp.id IS NOT NULL THEN json_build_object(
    'id', emp.id,
    'name', emp.name
  ) ELSE NULL END
) INTO personal_data
FROM patient_personal pp
LEFT JOIN countries bc ON pp.birth_country_id = bc.id
LEFT JOIN cities bci ON pp.birth_city_id = bci.id
LEFT JOIN professions prof ON pp.profession_id = prof.id
LEFT JOIN companies emp ON pp.employer_id = emp.id  -- Add this JOIN
WHERE pp.patient_id = p_patient_id;

  -- =================================================================
  -- Get risk data
  -- =================================================================
  SELECT row_to_json(rv) INTO risk_data
  FROM patient_risk_view rv
  WHERE rv.patient_id = p_patient_id;

  -- =================================================================
  -- Get patient notes --
  -- =================================================================
  SELECT json_agg(n) INTO notes_data
  FROM patient_notes n
  WHERE n.patient_id = p_patient_id;

  -- Combine everything into a single JSON object
  RETURN json_build_object(
    'general', general_data,
    'personal', personal_data,
    'risk', risk_data,
    'notes', notes_data,
    'id_documents', id_documents_data,
    'insurances', insurances_data
  );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_patient_list_basic(p_limit integer DEFAULT 20, p_offset integer DEFAULT 0, p_first_name text DEFAULT NULL::text, p_last_name text DEFAULT NULL::text, p_national_id text DEFAULT NULL::text, p_phone text DEFAULT NULL::text, p_sort text DEFAULT 'created_at'::text, p_order text DEFAULT 'desc'::text, p_min_chars integer DEFAULT 2)
 RETURNS jsonb
 LANGUAGE plpgsql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
DECLARE
  v_total_count BIGINT;
  v_filtered_count BIGINT;
  v_data JSONB;
  v_is_asc BOOLEAN;
  v_has_filters BOOLEAN;
  v_first_name TEXT;
  v_last_name TEXT;
  v_national_id TEXT;
  v_phone TEXT;
BEGIN
  v_is_asc := LOWER(p_order) = 'asc';

  -- Normalize filters: treat as NULL if empty or below minimum character threshold
  v_first_name := CASE 
    WHEN p_first_name IS NOT NULL AND LENGTH(TRIM(p_first_name)) >= p_min_chars 
    THEN TRIM(p_first_name) 
    ELSE NULL 
  END;
  
  v_last_name := CASE 
    WHEN p_last_name IS NOT NULL AND LENGTH(TRIM(p_last_name)) >= p_min_chars 
    THEN TRIM(p_last_name) 
    ELSE NULL 
  END;
  
  v_national_id := CASE 
    WHEN p_national_id IS NOT NULL AND LENGTH(TRIM(p_national_id)) >= p_min_chars 
    THEN TRIM(p_national_id) 
    ELSE NULL 
  END;
  
  v_phone := CASE 
    WHEN p_phone IS NOT NULL AND LENGTH(TRIM(p_phone)) >= p_min_chars 
    THEN TRIM(p_phone) 
    ELSE NULL 
  END;

  v_has_filters := v_first_name IS NOT NULL 
                OR v_last_name IS NOT NULL 
                OR v_national_id IS NOT NULL 
                OR v_phone IS NOT NULL;

  -- Fast approximate count for total (O(1) lookup)
  SELECT COALESCE(reltuples::BIGINT, 0) 
  INTO v_total_count 
  FROM pg_class 
  WHERE relname = 'patient_general' AND relnamespace = 'public'::regnamespace;

  IF NOT v_has_filters THEN
    v_filtered_count := v_total_count;
  ELSE
    SELECT COUNT(*) INTO v_filtered_count
    FROM patient_general
    WHERE 
      (v_first_name IS NULL OR first_name ILIKE '%' || v_first_name || '%')
      AND (v_last_name IS NULL OR last_name ILIKE '%' || v_last_name || '%')
      AND (v_national_id IS NULL OR national_id_number ILIKE '%' || v_national_id || '%')
      AND (v_phone IS NULL OR phone ILIKE '%' || v_phone || '%');
  END IF;

  SELECT COALESCE(jsonb_agg(row_data), '[]'::jsonb)
  INTO v_data
  FROM (
    SELECT 
      jsonb_build_object(
        'id', pg.id,
        'firstName', pg.first_name,
        'lastName', pg.last_name,
        'nationalIdNumber', pg.national_id_number,
        'dateOfBirth', pg.date_of_birth,
        'phone', pg.phone,
        'email', pg.email,
        'residenceAddress', pg.residence_address,
        'residenceCountryIso2', c.iso2,
        'residenceCityName', ci.name,
        'residenceCityPostalCode', ci.postal_code,
        'emergencyContactName', pg.emergency_contact_name,
        'emergencyContactPhone', pg.emergency_contact_phone,
        'emergencyContactRelation', pg.emergency_contact_relation,
        'createdAt', pg.created_at,
        'updatedAt', pg.updated_at
      ) AS row_data
    FROM patient_general pg
    LEFT JOIN countries c ON pg.residence_country_id = c.id
    LEFT JOIN cities ci ON pg.residence_city_id = ci.id
    WHERE 
      (v_first_name IS NULL OR pg.first_name ILIKE '%' || v_first_name || '%')
      AND (v_last_name IS NULL OR pg.last_name ILIKE '%' || v_last_name || '%')
      AND (v_national_id IS NULL OR pg.national_id_number ILIKE '%' || v_national_id || '%')
      AND (v_phone IS NULL OR pg.phone ILIKE '%' || v_phone || '%')
    ORDER BY
      CASE WHEN p_sort = 'created_at' AND v_is_asc THEN pg.created_at END ASC NULLS LAST,
      CASE WHEN p_sort = 'created_at' AND NOT v_is_asc THEN pg.created_at END DESC NULLS LAST,
      CASE WHEN p_sort = 'first_name' AND v_is_asc THEN pg.first_name END ASC NULLS LAST,
      CASE WHEN p_sort = 'first_name' AND NOT v_is_asc THEN pg.first_name END DESC NULLS LAST,
      CASE WHEN p_sort = 'last_name' AND v_is_asc THEN pg.last_name END ASC NULLS LAST,
      CASE WHEN p_sort = 'last_name' AND NOT v_is_asc THEN pg.last_name END DESC NULLS LAST,
      CASE WHEN p_sort = 'date_of_birth' AND v_is_asc THEN pg.date_of_birth END ASC NULLS LAST,
      CASE WHEN p_sort = 'date_of_birth' AND NOT v_is_asc THEN pg.date_of_birth END DESC NULLS LAST
    LIMIT p_limit
    OFFSET p_offset
  ) subquery;

  RETURN jsonb_build_object(
    'data', v_data,
    'filteredCount', v_filtered_count,
    'totalCount', v_total_count,
    'pagination', jsonb_build_object(
      'page', (p_offset / p_limit) + 1,
      'limit', p_limit,
      'totalPages', CEIL(v_filtered_count::DECIMAL / p_limit)
    )
  );
END;
$function$
;

grant delete on table "public"."companies" to "postgres";

grant insert on table "public"."companies" to "postgres";

grant references on table "public"."companies" to "postgres";

grant select on table "public"."companies" to "postgres";

grant trigger on table "public"."companies" to "postgres";

grant truncate on table "public"."companies" to "postgres";

grant update on table "public"."companies" to "postgres";

grant delete on table "public"."professions" to "anon";

grant insert on table "public"."professions" to "anon";

grant references on table "public"."professions" to "anon";

grant select on table "public"."professions" to "anon";

grant trigger on table "public"."professions" to "anon";

grant truncate on table "public"."professions" to "anon";

grant update on table "public"."professions" to "anon";

grant delete on table "public"."professions" to "authenticated";

grant insert on table "public"."professions" to "authenticated";

grant references on table "public"."professions" to "authenticated";

grant select on table "public"."professions" to "authenticated";

grant trigger on table "public"."professions" to "authenticated";

grant truncate on table "public"."professions" to "authenticated";

grant update on table "public"."professions" to "authenticated";

grant delete on table "public"."professions" to "postgres";

grant insert on table "public"."professions" to "postgres";

grant references on table "public"."professions" to "postgres";

grant select on table "public"."professions" to "postgres";

grant trigger on table "public"."professions" to "postgres";

grant truncate on table "public"."professions" to "postgres";

grant update on table "public"."professions" to "postgres";

grant delete on table "public"."professions" to "service_role";

grant insert on table "public"."professions" to "service_role";

grant references on table "public"."professions" to "service_role";

grant select on table "public"."professions" to "service_role";

grant trigger on table "public"."professions" to "service_role";

grant truncate on table "public"."professions" to "service_role";

grant update on table "public"."professions" to "service_role";


  create policy "Allow authenticated users to delete professions"
  on "public"."professions"
  as permissive
  for delete
  to authenticated
using (true);



  create policy "Allow authenticated users to insert professions"
  on "public"."professions"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Allow authenticated users to read professions"
  on "public"."professions"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Allow authenticated users to update professions"
  on "public"."professions"
  as permissive
  for update
  to authenticated
using (true);



  create policy "Allow service_role full access"
  on "public"."professions"
  as permissive
  for all
  to service_role
using (true);



